package light

import (
	"context"
	"errors"
	"fmt"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/rawdb"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/log"
)

const (
	EmptyContractAddress = "0x0000000000000000000000000000000000000000"
)

func syncByHeader(lc *LightChain, chain []*types.Header) error {

	for _, header := range chain {
		// log.Info(fmt.Sprintf("ankr header is %s", header.Number.String()))

		_, err := GetBlockReceiptsSync(context.Background(), lc.odr, header.Hash(), header.Number.Uint64())
		if err != nil {
			return errors.New(fmt.Sprintf("ankr GetBlockReceipts error is %v", err.Error()))
		}

	}
	return nil
}

// GetBlockReceipts retrieves the receipts generated by the transactions included
// in a block given by its hash.
func GetBlockReceiptsSync(ctx context.Context, odr OdrBackend, hash common.Hash, number uint64) (types.Receipts, error) {

	var (
		insertReceipts types.Receipts
	)

	// Assume receipts are already stored locally and attempt to retrieve.

	receipts := rawdb.ReadRawReceipts(odr.Database(), hash, number)
	if receipts == nil {
		header, err := GetHeaderByNumber(ctx, odr, number)
		if err != nil {
			return nil, errNoHeader
		}
		if header.Hash() != hash {
			return nil, errNonCanonicalHash
		}
		r := &ReceiptsRequest{Hash: hash, Number: number, Header: header}
		if err := odr.Retrieve(ctx, r); err != nil {
			return nil, err
		}
		receipts = r.Receipts
	}
	// If the receipts are incomplete, fill the derived fields
	if len(receipts) > 0 && receipts[0].TxHash == (common.Hash{}) {
		block, err := GetBlock(ctx, odr, hash, number)
		log.Info(fmt.Sprintf("ankrBlockSave %d", block.NumberU64()))
		if err != nil {
			return nil, err
		}
		genesis := rawdb.ReadCanonicalHash(odr.Database(), 0)
		config := rawdb.ReadChainConfig(odr.Database(), genesis)

		if err := receipts.DeriveFields(config, block.Hash(), block.NumberU64(), block.Transactions()); err != nil {
			return nil, err
		}
	}

	for _, receipt := range receipts {
		if receipt.ContractAddress.String() != EmptyContractAddress {
			insertReceipts = append(insertReceipts, receipt)
			log.Info(fmt.Sprintf("ankrReceiptSave %s", receipt.TxHash.String()))
			receiptJson, _ := receipt.MarshalJSON()
			log.Info(fmt.Sprintf("ankrReceiptSaveReceipt %s", receiptJson))
		}
	}

	rawdb.WriteReceipts(odr.Database(), hash, number, insertReceipts)

	return receipts, nil
}
