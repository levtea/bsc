package light

import (
	"context"
	"errors"
	"fmt"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/rawdb"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/log"
)

const (
	EmptyContractAddress = "0x0000000000000000000000000000000000000000"
)

func syncByHeader(lc *LightChain, chain []*types.Header) error {
	willInsertHeaderSet := make(map[*types.Header]struct{})
	for _, header := range chain {
		// log.Info(fmt.Sprintf("ankr header is %s", header.Number.String()))

		receipts, err := GetBlockReceipts(context.Background(), lc.odr, header.Hash(), header.Number.Uint64())
		if err != nil {
			return errors.New(fmt.Sprintf("ankr GetBlockReceipts error is %v", err.Error()))
		}
		for _, receipt := range receipts {
			receiptJson, _ := receipt.MarshalJSON()
			log.Info(fmt.Sprintf("ankr receipt is %s", string(receiptJson)))
			log.Info(fmt.Sprintf("ankr contract_address is %s", receipt.ContractAddress))

			// if receipt.ContractAddress.String() != EmptyContractAddress {
			// 	willInsertHeaderSet[header] = struct{}{}
			// }
		}
		willInsertHeaderSet[header] = struct{}{}
	}
	if len(willInsertHeaderSet) != 0 {
		for headerInsert := range willInsertHeaderSet {
			block, err := lc.GetBlock(context.Background(), headerInsert.Hash(), headerInsert.Number.Uint64())
			if err != nil {
				return errors.New(fmt.Sprintf("ankr GetBlockByHash error is %v", err))
			}
			log.Info(fmt.Sprintf("ankr savedBlock is %s", block.Number()))
		}
	}
	return nil
}

// GetBlockReceipts retrieves the receipts generated by the transactions included
// in a block given by its hash.
func GetBlockReceiptsSync(ctx context.Context, odr OdrBackend, hash common.Hash, number uint64) (types.Receipts, error) {

	var (
		insertReceipts types.Receipts
	)

	// Assume receipts are already stored locally and attempt to retrieve.
	receipts := rawdb.ReadRawReceipts(odr.Database(), hash, number)
	if receipts == nil {
		header, err := GetHeaderByNumber(ctx, odr, number)
		if err != nil {
			return nil, errNoHeader
		}
		if header.Hash() != hash {
			return nil, errNonCanonicalHash
		}
		r := &ReceiptsRequest{Hash: hash, Number: number, Header: header}
		if err := odr.Retrieve(ctx, r); err != nil {
			return nil, err
		}
		receipts = r.Receipts
	}
	// If the receipts are incomplete, fill the derived fields
	if len(receipts) > 0 && receipts[0].TxHash == (common.Hash{}) {
		block, err := GetBlock(ctx, odr, hash, number)
		if err != nil {
			return nil, err
		}
		genesis := rawdb.ReadCanonicalHash(odr.Database(), 0)
		config := rawdb.ReadChainConfig(odr.Database(), genesis)

		if err := receipts.DeriveFields(config, block.Hash(), block.NumberU64(), block.Transactions()); err != nil {
			return nil, err
		}
		for _, receipt := range receipts {
			if receipt.ContractAddress.String() != EmptyContractAddress {
				receiptJson, _ := receipt.MarshalJSON()
				log.Info(fmt.Sprintf("ankr receipt is %s", string(receiptJson)))
				insertReceipts = append(insertReceipts, receipt)
				// log.Info(fmt.Sprintf("ankr will saveReceipt %s", receipt.ContractAddress.String()))
			}
		}
		rawdb.WriteReceipts(odr.Database(), hash, number, insertReceipts)

	}
	return receipts, nil
}
